CCS PCM C Compiler, Version 5.015, 5967               16-Jun-23 18:01

               Filename:   C:\Users\leho8\OneDrive\Máy tính\DOAN_1\code ccs\doan1_1.lst

               ROM used:   2480 words (30%)
                           Largest free fragment is 2048
               RAM used:   33 (9%) at main() level
                           58 (16%) worst case
               Stack used: 5 locations
               Stack size: 8

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
.................... #include <16F877a.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0004:  DATA C1,31
0005:  DATA F4,34
0006:  DATA F6,32
0007:  DATA A0,26
0008:  DATA 6F,32
0009:  DATA 65,1D
000A:  DATA A0,26
000B:  DATA 61,37
000C:  DATA F5,30
000D:  DATA 6C,00
000E:  DATA 54,21
000F:  DATA 31,1D
0010:  DATA 31,10
0011:  DATA 20,10
0012:  DATA D4,32
0013:  DATA 6D,38
0014:  DATA BA,27
0015:  DATA 46,23
0016:  DATA 20,10
0017:  DATA 20,10
0018:  DATA 00,01
0019:  DATA 54,21
001A:  DATA 31,1D
001B:  DATA 30,10
001C:  DATA 20,10
001D:  DATA D4,32
001E:  DATA 6D,38
001F:  DATA BA,27
0020:  DATA 46,23
0021:  DATA 20,10
0022:  DATA 20,10
0023:  DATA 00,01
0024:  DATA 54,21
0025:  DATA 32,1D
0026:  DATA 31,10
0027:  DATA 20,10
0028:  DATA C8,3A
0029:  DATA ED,34
002A:  DATA BA,27
002B:  DATA 46,23
002C:  DATA 20,10
002D:  DATA 20,00
002E:  DATA 54,21
002F:  DATA 32,1D
0030:  DATA 30,10
0031:  DATA 20,10
0032:  DATA C8,3A
0033:  DATA ED,34
0034:  DATA BA,27
0035:  DATA 46,23
0036:  DATA 20,10
0037:  DATA 20,00
0038:  DATA 54,21
0039:  DATA 33,1D
003A:  DATA 31,10
003B:  DATA 20,10
003C:  DATA 49,37
003D:  DATA F4,32
003E:  DATA BA,27
003F:  DATA 46,23
0040:  DATA 20,10
0041:  DATA 20,00
0042:  DATA 54,21
0043:  DATA 33,1D
0044:  DATA 30,10
0045:  DATA 20,10
0046:  DATA 49,37
0047:  DATA F4,32
0048:  DATA BA,27
0049:  DATA 46,23
004A:  DATA 20,10
004B:  DATA 20,00
004C:  DATA C1,31
004D:  DATA F4,34
004E:  DATA F6,32
004F:  DATA A0,26
0050:  DATA 6F,32
0051:  DATA 65,1D
0052:  DATA A0,20
0053:  DATA 75,3A
0054:  DATA 6F,10
0055:  DATA 20,00
0056:  DATA 54,21
0057:  DATA 31,1D
0058:  DATA 31,10
0059:  DATA 20,10
005A:  DATA D4,32
005B:  DATA 6D,38
005C:  DATA BA,12
005D:  DATA 33,17
005E:  DATA 31,33
005F:  DATA 00,00
0060:  DATA 43,10
0061:  DATA 00,01
0062:  DATA 54,21
0063:  DATA 31,1D
0064:  DATA 30,10
0065:  DATA 20,10
0066:  DATA D4,32
0067:  DATA 6D,38
0068:  DATA BA,12
0069:  DATA 33,17
006A:  DATA 31,33
006B:  DATA 00,01
006C:  DATA 43,10
006D:  DATA 00,01
006E:  DATA 54,21
006F:  DATA 32,1D
0070:  DATA 31,10
0071:  DATA 20,10
0072:  DATA C8,3A
0073:  DATA ED,34
0074:  DATA BA,12
0075:  DATA 33,17
0076:  DATA 31,33
0077:  DATA A5,12
0078:  DATA 20,00
0079:  DATA 54,21
007A:  DATA 32,1D
007B:  DATA 30,10
007C:  DATA 20,10
007D:  DATA C8,3A
007E:  DATA ED,34
007F:  DATA BA,12
0080:  DATA 33,17
0081:  DATA 31,33
0082:  DATA A5,12
0083:  DATA 20,00
0084:  DATA 54,21
0085:  DATA 33,1D
0086:  DATA 31,10
0087:  DATA 20,10
0088:  DATA 49,37
0089:  DATA F4,32
008A:  DATA BA,12
008B:  DATA 34,17
008C:  DATA 31,33
008D:  DATA 00,01
008E:  DATA 54,21
008F:  DATA 33,1D
0090:  DATA 30,10
0091:  DATA 20,10
0092:  DATA 49,37
0093:  DATA F4,32
0094:  DATA BA,12
0095:  DATA 34,17
0096:  DATA 31,33
0097:  DATA 00,00
*
0117:  MOVF   0B,W
0118:  MOVWF  3B
0119:  BCF    0B.7
011A:  BSF    03.5
011B:  BSF    03.6
011C:  BSF    0C.7
011D:  BSF    0C.0
011E:  NOP
011F:  NOP
0120:  BCF    03.5
0121:  BCF    03.6
0122:  BTFSC  3B.7
0123:  BSF    0B.7
0124:  BSF    03.6
0125:  MOVF   0C,W
0126:  ANDLW  7F
0127:  BTFSC  03.2
0128:  GOTO   16B
0129:  BCF    03.6
012A:  MOVWF  3B
012B:  BSF    03.6
012C:  MOVF   0D,W
012D:  BCF    03.6
012E:  MOVWF  3C
012F:  BSF    03.6
0130:  MOVF   0F,W
0131:  BCF    03.6
0132:  MOVWF  3D
0133:  MOVF   3B,W
0134:  MOVWF  48
0135:  CALL   10B
0136:  MOVF   3C,W
0137:  BSF    03.6
0138:  MOVWF  0D
0139:  BCF    03.6
013A:  MOVF   3D,W
013B:  BSF    03.6
013C:  MOVWF  0F
013D:  BCF    03.6
013E:  MOVF   0B,W
013F:  MOVWF  3E
0140:  BCF    0B.7
0141:  BSF    03.5
0142:  BSF    03.6
0143:  BSF    0C.7
0144:  BSF    0C.0
0145:  NOP
0146:  NOP
0147:  BCF    03.5
0148:  BCF    03.6
0149:  BTFSC  3E.7
014A:  BSF    0B.7
014B:  BSF    03.6
014C:  RLF    0C,W
014D:  RLF    0E,W
014E:  ANDLW  7F
014F:  BTFSC  03.2
0150:  GOTO   16B
0151:  BCF    03.6
0152:  MOVWF  3B
0153:  BSF    03.6
0154:  MOVF   0D,W
0155:  BCF    03.6
0156:  MOVWF  3C
0157:  BSF    03.6
0158:  MOVF   0F,W
0159:  BCF    03.6
015A:  MOVWF  3D
015B:  MOVF   3B,W
015C:  MOVWF  48
015D:  CALL   10B
015E:  MOVF   3C,W
015F:  BSF    03.6
0160:  MOVWF  0D
0161:  BCF    03.6
0162:  MOVF   3D,W
0163:  BSF    03.6
0164:  MOVWF  0F
0165:  INCF   0D,F
0166:  BTFSC  03.2
0167:  INCF   0F,F
0168:  BCF    03.6
0169:  GOTO   117
016A:  BSF    03.6
016B:  BCF    03.6
016C:  RETURN
016D:  MOVLW  8E
016E:  MOVWF  77
016F:  MOVF   3C,W
0170:  MOVWF  78
0171:  MOVF   3B,W
0172:  MOVWF  79
0173:  CLRF   7A
0174:  MOVF   78,F
0175:  BTFSS  03.2
0176:  GOTO   181
0177:  MOVF   79,W
0178:  MOVWF  78
0179:  CLRF   79
017A:  MOVLW  08
017B:  SUBWF  77,F
017C:  MOVF   78,F
017D:  BTFSS  03.2
017E:  GOTO   181
017F:  CLRF   77
0180:  GOTO   189
0181:  BCF    03.0
0182:  BTFSC  78.7
0183:  GOTO   188
0184:  RLF    79,F
0185:  RLF    78,F
0186:  DECF   77,F
0187:  GOTO   181
0188:  BCF    78.7
0189:  RETURN
018A:  MOVF   48,W
018B:  BTFSC  03.2
018C:  GOTO   1FA
018D:  MOVWF  50
018E:  MOVF   4C,W
018F:  BTFSC  03.2
0190:  GOTO   1FA
0191:  ADDWF  50,F
0192:  BTFSC  03.0
0193:  GOTO   19B
0194:  MOVLW  7F
0195:  SUBWF  50,F
0196:  BTFSS  03.0
0197:  GOTO   1FA
0198:  BTFSC  03.2
0199:  GOTO   1FA
019A:  GOTO   19F
019B:  MOVLW  81
019C:  ADDWF  50,F
019D:  BTFSC  03.0
019E:  GOTO   1FA
019F:  MOVF   50,W
01A0:  MOVWF  77
01A1:  CLRF   78
01A2:  CLRF   79
01A3:  CLRF   7A
01A4:  MOVF   49,W
01A5:  MOVWF  54
01A6:  BSF    54.7
01A7:  MOVF   4A,W
01A8:  MOVWF  53
01A9:  MOVF   4B,W
01AA:  MOVWF  52
01AB:  MOVLW  18
01AC:  MOVWF  50
01AD:  CLRF   51
01AE:  BTFSS  52.0
01AF:  GOTO   1C8
01B0:  MOVF   4F,W
01B1:  ADDWF  7A,F
01B2:  BTFSS  03.0
01B3:  GOTO   1BA
01B4:  INCF   79,F
01B5:  BTFSS  03.2
01B6:  GOTO   1BA
01B7:  INCF   78,F
01B8:  BTFSC  03.2
01B9:  BSF    51.7
01BA:  MOVF   4E,W
01BB:  ADDWF  79,F
01BC:  BTFSS  03.0
01BD:  GOTO   1C1
01BE:  INCF   78,F
01BF:  BTFSC  03.2
01C0:  BSF    51.7
01C1:  MOVF   4D,W
01C2:  MOVWF  4A
01C3:  BSF    4A.7
01C4:  MOVF   4A,W
01C5:  ADDWF  78,F
01C6:  BTFSC  03.0
01C7:  BSF    51.7
01C8:  RLF    51,F
01C9:  RRF    78,F
01CA:  RRF    79,F
01CB:  RRF    7A,F
01CC:  RRF    54,F
01CD:  RRF    53,F
01CE:  RRF    52,F
01CF:  BCF    03.0
01D0:  DECFSZ 50,F
01D1:  GOTO   1AD
01D2:  MOVLW  01
01D3:  ADDWF  77,F
01D4:  BTFSC  03.0
01D5:  GOTO   1FA
01D6:  BTFSC  78.7
01D7:  GOTO   1DF
01D8:  RLF    54,F
01D9:  RLF    7A,F
01DA:  RLF    79,F
01DB:  RLF    78,F
01DC:  DECF   77,F
01DD:  BTFSC  03.2
01DE:  GOTO   1FA
01DF:  BTFSS  54.7
01E0:  GOTO   1F0
01E1:  INCF   7A,F
01E2:  BTFSS  03.2
01E3:  GOTO   1F0
01E4:  INCF   79,F
01E5:  BTFSS  03.2
01E6:  GOTO   1F0
01E7:  INCF   78,F
01E8:  BTFSS  03.2
01E9:  GOTO   1F0
01EA:  RRF    78,F
01EB:  RRF    79,F
01EC:  RRF    7A,F
01ED:  INCF   77,F
01EE:  BTFSC  03.2
01EF:  GOTO   1FA
01F0:  MOVF   49,W
01F1:  MOVWF  51
01F2:  MOVF   4D,W
01F3:  XORWF  51,F
01F4:  BTFSS  51.7
01F5:  GOTO   1F8
01F6:  BSF    78.7
01F7:  GOTO   1FE
01F8:  BCF    78.7
01F9:  GOTO   1FE
01FA:  CLRF   77
01FB:  CLRF   78
01FC:  CLRF   79
01FD:  CLRF   7A
01FE:  RETURN
01FF:  MOVF   3F,W
0200:  BTFSC  03.2
0201:  GOTO   2C4
0202:  MOVWF  4B
0203:  MOVF   43,W
0204:  BTFSC  03.2
0205:  GOTO   2C4
0206:  SUBWF  4B,F
0207:  BTFSS  03.0
0208:  GOTO   20E
0209:  MOVLW  7F
020A:  ADDWF  4B,F
020B:  BTFSC  03.0
020C:  GOTO   2C4
020D:  GOTO   214
020E:  MOVLW  81
020F:  SUBWF  4B,F
0210:  BTFSS  03.0
0211:  GOTO   2C4
0212:  BTFSC  03.2
0213:  GOTO   2C4
0214:  MOVF   4B,W
0215:  MOVWF  77
0216:  CLRF   78
0217:  CLRF   79
0218:  CLRF   7A
0219:  CLRF   4A
021A:  MOVF   40,W
021B:  MOVWF  49
021C:  BSF    49.7
021D:  MOVF   41,W
021E:  MOVWF  48
021F:  MOVF   42,W
0220:  MOVWF  47
0221:  MOVLW  19
0222:  MOVWF  4B
0223:  MOVF   46,W
0224:  SUBWF  47,F
0225:  BTFSC  03.0
0226:  GOTO   237
0227:  MOVLW  01
0228:  SUBWF  48,F
0229:  BTFSC  03.0
022A:  GOTO   237
022B:  SUBWF  49,F
022C:  BTFSC  03.0
022D:  GOTO   237
022E:  SUBWF  4A,F
022F:  BTFSC  03.0
0230:  GOTO   237
0231:  INCF   4A,F
0232:  INCF   49,F
0233:  INCF   48,F
0234:  MOVF   46,W
0235:  ADDWF  47,F
0236:  GOTO   269
0237:  MOVF   45,W
0238:  SUBWF  48,F
0239:  BTFSC  03.0
023A:  GOTO   252
023B:  MOVLW  01
023C:  SUBWF  49,F
023D:  BTFSC  03.0
023E:  GOTO   252
023F:  SUBWF  4A,F
0240:  BTFSC  03.0
0241:  GOTO   252
0242:  INCF   4A,F
0243:  INCF   49,F
0244:  MOVF   45,W
0245:  ADDWF  48,F
0246:  MOVF   46,W
0247:  ADDWF  47,F
0248:  BTFSS  03.0
0249:  GOTO   269
024A:  INCF   48,F
024B:  BTFSS  03.2
024C:  GOTO   269
024D:  INCF   49,F
024E:  BTFSS  03.2
024F:  GOTO   269
0250:  INCF   4A,F
0251:  GOTO   269
0252:  MOVF   44,W
0253:  IORLW  80
0254:  SUBWF  49,F
0255:  BTFSC  03.0
0256:  GOTO   268
0257:  MOVLW  01
0258:  SUBWF  4A,F
0259:  BTFSC  03.0
025A:  GOTO   268
025B:  INCF   4A,F
025C:  MOVF   44,W
025D:  IORLW  80
025E:  ADDWF  49,F
025F:  MOVF   45,W
0260:  ADDWF  48,F
0261:  BTFSS  03.0
0262:  GOTO   246
0263:  INCF   49,F
0264:  BTFSS  03.2
0265:  GOTO   246
0266:  INCF   4A,F
0267:  GOTO   246
0268:  BSF    7A.0
0269:  DECFSZ 4B,F
026A:  GOTO   26C
026B:  GOTO   277
026C:  BCF    03.0
026D:  RLF    47,F
026E:  RLF    48,F
026F:  RLF    49,F
0270:  RLF    4A,F
0271:  BCF    03.0
0272:  RLF    7A,F
0273:  RLF    79,F
0274:  RLF    78,F
0275:  RLF    4C,F
0276:  GOTO   223
0277:  BTFSS  4C.0
0278:  GOTO   27F
0279:  BCF    03.0
027A:  RRF    78,F
027B:  RRF    79,F
027C:  RRF    7A,F
027D:  RRF    4C,F
027E:  GOTO   282
027F:  DECF   77,F
0280:  BTFSC  03.2
0281:  GOTO   2C4
0282:  BTFSC  4C.7
0283:  GOTO   2AB
0284:  BCF    03.0
0285:  RLF    47,F
0286:  RLF    48,F
0287:  RLF    49,F
0288:  RLF    4A,F
0289:  MOVF   46,W
028A:  SUBWF  47,F
028B:  BTFSC  03.0
028C:  GOTO   297
028D:  MOVLW  01
028E:  SUBWF  48,F
028F:  BTFSC  03.0
0290:  GOTO   297
0291:  SUBWF  49,F
0292:  BTFSC  03.0
0293:  GOTO   297
0294:  SUBWF  4A,F
0295:  BTFSS  03.0
0296:  GOTO   2BA
0297:  MOVF   45,W
0298:  SUBWF  48,F
0299:  BTFSC  03.0
029A:  GOTO   2A2
029B:  MOVLW  01
029C:  SUBWF  49,F
029D:  BTFSC  03.0
029E:  GOTO   2A2
029F:  SUBWF  4A,F
02A0:  BTFSS  03.0
02A1:  GOTO   2BA
02A2:  MOVF   44,W
02A3:  IORLW  80
02A4:  SUBWF  49,F
02A5:  BTFSC  03.0
02A6:  GOTO   2AB
02A7:  MOVLW  01
02A8:  SUBWF  4A,F
02A9:  BTFSS  03.0
02AA:  GOTO   2BA
02AB:  INCF   7A,F
02AC:  BTFSS  03.2
02AD:  GOTO   2BA
02AE:  INCF   79,F
02AF:  BTFSS  03.2
02B0:  GOTO   2BA
02B1:  INCF   78,F
02B2:  BTFSS  03.2
02B3:  GOTO   2BA
02B4:  INCF   77,F
02B5:  BTFSC  03.2
02B6:  GOTO   2C4
02B7:  RRF    78,F
02B8:  RRF    79,F
02B9:  RRF    7A,F
02BA:  MOVF   40,W
02BB:  MOVWF  4B
02BC:  MOVF   44,W
02BD:  XORWF  4B,F
02BE:  BTFSS  4B.7
02BF:  GOTO   2C2
02C0:  BSF    78.7
02C1:  GOTO   2C8
02C2:  BCF    78.7
02C3:  GOTO   2C8
02C4:  CLRF   77
02C5:  CLRF   78
02C6:  CLRF   79
02C7:  CLRF   7A
02C8:  RETURN
*
036B:  MOVLW  80
036C:  BTFSC  03.1
036D:  XORWF  40,F
036E:  CLRF   45
036F:  CLRF   46
0370:  MOVF   3C,W
0371:  MOVWF  44
0372:  MOVF   40,W
0373:  XORWF  44,F
0374:  MOVF   3B,W
0375:  BTFSC  03.2
0376:  GOTO   45B
0377:  MOVWF  43
0378:  MOVWF  77
0379:  MOVF   3F,W
037A:  BTFSC  03.2
037B:  GOTO   464
037C:  SUBWF  43,F
037D:  BTFSC  03.2
037E:  GOTO   400
037F:  BTFSS  03.0
0380:  GOTO   3BE
0381:  MOVF   40,W
0382:  MOVWF  49
0383:  BSF    49.7
0384:  MOVF   41,W
0385:  MOVWF  48
0386:  MOVF   42,W
0387:  MOVWF  47
0388:  CLRF   46
0389:  BCF    03.0
038A:  RRF    49,F
038B:  RRF    48,F
038C:  RRF    47,F
038D:  RRF    46,F
038E:  DECFSZ 43,F
038F:  GOTO   388
0390:  BTFSS  44.7
0391:  GOTO   395
0392:  BSF    45.0
0393:  GOTO   478
0394:  BCF    45.0
0395:  BCF    43.0
0396:  BSF    45.4
0397:  MOVLW  3E
0398:  MOVWF  04
0399:  BCF    03.7
039A:  GOTO   48D
039B:  BCF    45.4
039C:  BTFSC  44.7
039D:  GOTO   3A8
039E:  BTFSS  43.0
039F:  GOTO   3B3
03A0:  RRF    49,F
03A1:  RRF    48,F
03A2:  RRF    47,F
03A3:  RRF    46,F
03A4:  INCF   77,F
03A5:  BTFSC  03.2
03A6:  GOTO   473
03A7:  GOTO   3B3
03A8:  BTFSC  49.7
03A9:  GOTO   3B6
03AA:  BCF    03.0
03AB:  RLF    46,F
03AC:  RLF    47,F
03AD:  RLF    48,F
03AE:  RLF    49,F
03AF:  DECF   77,F
03B0:  BTFSC  03.2
03B1:  GOTO   473
03B2:  GOTO   3A8
03B3:  BSF    45.6
03B4:  GOTO   420
03B5:  BCF    45.6
03B6:  MOVF   3C,W
03B7:  MOVWF  44
03B8:  BTFSS  44.7
03B9:  GOTO   3BC
03BA:  BSF    49.7
03BB:  GOTO   46C
03BC:  BCF    49.7
03BD:  GOTO   46C
03BE:  MOVF   3F,W
03BF:  MOVWF  43
03C0:  MOVWF  77
03C1:  MOVF   3B,W
03C2:  SUBWF  43,F
03C3:  MOVF   3C,W
03C4:  MOVWF  49
03C5:  BSF    49.7
03C6:  MOVF   3D,W
03C7:  MOVWF  48
03C8:  MOVF   3E,W
03C9:  MOVWF  47
03CA:  CLRF   46
03CB:  BCF    03.0
03CC:  RRF    49,F
03CD:  RRF    48,F
03CE:  RRF    47,F
03CF:  RRF    46,F
03D0:  DECFSZ 43,F
03D1:  GOTO   3CA
03D2:  BTFSS  44.7
03D3:  GOTO   3D7
03D4:  BSF    45.1
03D5:  GOTO   478
03D6:  BCF    45.1
03D7:  BCF    43.0
03D8:  BSF    45.5
03D9:  MOVLW  42
03DA:  MOVWF  04
03DB:  BCF    03.7
03DC:  GOTO   48D
03DD:  BCF    45.5
03DE:  BTFSC  44.7
03DF:  GOTO   3EA
03E0:  BTFSS  43.0
03E1:  GOTO   3F5
03E2:  RRF    49,F
03E3:  RRF    48,F
03E4:  RRF    47,F
03E5:  RRF    46,F
03E6:  INCF   77,F
03E7:  BTFSC  03.2
03E8:  GOTO   473
03E9:  GOTO   3F5
03EA:  BTFSC  49.7
03EB:  GOTO   3F8
03EC:  BCF    03.0
03ED:  RLF    46,F
03EE:  RLF    47,F
03EF:  RLF    48,F
03F0:  RLF    49,F
03F1:  DECF   77,F
03F2:  BTFSC  03.2
03F3:  GOTO   473
03F4:  GOTO   3EA
03F5:  BSF    45.7
03F6:  GOTO   420
03F7:  BCF    45.7
03F8:  MOVF   40,W
03F9:  MOVWF  44
03FA:  BTFSS  44.7
03FB:  GOTO   3FE
03FC:  BSF    49.7
03FD:  GOTO   46C
03FE:  BCF    49.7
03FF:  GOTO   46C
0400:  MOVF   40,W
0401:  MOVWF  49
0402:  BSF    49.7
0403:  MOVF   41,W
0404:  MOVWF  48
0405:  MOVF   42,W
0406:  MOVWF  47
0407:  BTFSS  44.7
0408:  GOTO   40D
0409:  BCF    49.7
040A:  BSF    45.2
040B:  GOTO   478
040C:  BCF    45.2
040D:  CLRF   46
040E:  BCF    43.0
040F:  MOVLW  3E
0410:  MOVWF  04
0411:  BCF    03.7
0412:  GOTO   48D
0413:  BTFSC  44.7
0414:  GOTO   436
0415:  MOVF   3C,W
0416:  MOVWF  44
0417:  BTFSS  43.0
0418:  GOTO   420
0419:  RRF    49,F
041A:  RRF    48,F
041B:  RRF    47,F
041C:  RRF    46,F
041D:  INCF   77,F
041E:  BTFSC  03.2
041F:  GOTO   473
0420:  BTFSS  46.7
0421:  GOTO   431
0422:  INCF   47,F
0423:  BTFSS  03.2
0424:  GOTO   431
0425:  INCF   48,F
0426:  BTFSS  03.2
0427:  GOTO   431
0428:  INCF   49,F
0429:  BTFSS  03.2
042A:  GOTO   431
042B:  RRF    49,F
042C:  RRF    48,F
042D:  RRF    47,F
042E:  INCF   77,F
042F:  BTFSC  03.2
0430:  GOTO   473
0431:  BTFSC  45.6
0432:  GOTO   3B5
0433:  BTFSC  45.7
0434:  GOTO   3F7
0435:  GOTO   455
0436:  MOVLW  80
0437:  XORWF  49,F
0438:  BTFSS  49.7
0439:  GOTO   43E
043A:  GOTO   478
043B:  MOVF   40,W
043C:  MOVWF  44
043D:  GOTO   44B
043E:  MOVF   3C,W
043F:  MOVWF  44
0440:  MOVF   49,F
0441:  BTFSS  03.2
0442:  GOTO   44B
0443:  MOVF   48,F
0444:  BTFSS  03.2
0445:  GOTO   44B
0446:  MOVF   47,F
0447:  BTFSS  03.2
0448:  GOTO   44B
0449:  CLRF   77
044A:  GOTO   46C
044B:  BTFSC  49.7
044C:  GOTO   455
044D:  BCF    03.0
044E:  RLF    46,F
044F:  RLF    47,F
0450:  RLF    48,F
0451:  RLF    49,F
0452:  DECFSZ 77,F
0453:  GOTO   44B
0454:  GOTO   473
0455:  BTFSS  44.7
0456:  GOTO   459
0457:  BSF    49.7
0458:  GOTO   46C
0459:  BCF    49.7
045A:  GOTO   46C
045B:  MOVF   3F,W
045C:  MOVWF  77
045D:  MOVF   40,W
045E:  MOVWF  49
045F:  MOVF   41,W
0460:  MOVWF  48
0461:  MOVF   42,W
0462:  MOVWF  47
0463:  GOTO   46C
0464:  MOVF   3B,W
0465:  MOVWF  77
0466:  MOVF   3C,W
0467:  MOVWF  49
0468:  MOVF   3D,W
0469:  MOVWF  48
046A:  MOVF   3E,W
046B:  MOVWF  47
046C:  MOVF   49,W
046D:  MOVWF  78
046E:  MOVF   48,W
046F:  MOVWF  79
0470:  MOVF   47,W
0471:  MOVWF  7A
0472:  GOTO   4AB
0473:  CLRF   77
0474:  CLRF   78
0475:  CLRF   79
0476:  CLRF   7A
0477:  GOTO   4AB
0478:  CLRF   46
0479:  COMF   47,F
047A:  COMF   48,F
047B:  COMF   49,F
047C:  COMF   46,F
047D:  INCF   46,F
047E:  BTFSS  03.2
047F:  GOTO   486
0480:  INCF   47,F
0481:  BTFSS  03.2
0482:  GOTO   486
0483:  INCF   48,F
0484:  BTFSC  03.2
0485:  INCF   49,F
0486:  BTFSC  45.0
0487:  GOTO   394
0488:  BTFSC  45.1
0489:  GOTO   3D6
048A:  BTFSC  45.2
048B:  GOTO   40C
048C:  GOTO   43B
048D:  MOVF   00,W
048E:  ADDWF  47,F
048F:  BTFSS  03.0
0490:  GOTO   497
0491:  INCF   48,F
0492:  BTFSS  03.2
0493:  GOTO   497
0494:  INCF   49,F
0495:  BTFSC  03.2
0496:  BSF    43.0
0497:  DECF   04,F
0498:  MOVF   00,W
0499:  ADDWF  48,F
049A:  BTFSS  03.0
049B:  GOTO   49F
049C:  INCF   49,F
049D:  BTFSC  03.2
049E:  BSF    43.0
049F:  DECF   04,F
04A0:  MOVF   00,W
04A1:  BTFSS  00.7
04A2:  XORLW  80
04A3:  ADDWF  49,F
04A4:  BTFSC  03.0
04A5:  BSF    43.0
04A6:  BTFSC  45.4
04A7:  GOTO   39B
04A8:  BTFSC  45.5
04A9:  GOTO   3DD
04AA:  GOTO   413
*
04D8:  MOVF   3C,W
04D9:  MOVWF  43
04DA:  MOVF   40,W
04DB:  XORWF  43,F
04DC:  BTFSS  43.7
04DD:  GOTO   4E3
04DE:  BCF    03.2
04DF:  BCF    03.0
04E0:  BTFSC  3C.7
04E1:  BSF    03.0
04E2:  GOTO   516
04E3:  MOVF   3C,W
04E4:  MOVWF  43
04E5:  MOVF   3F,W
04E6:  MOVWF  44
04E7:  MOVF   3B,W
04E8:  SUBWF  44,F
04E9:  BTFSC  03.2
04EA:  GOTO   4F1
04EB:  BTFSS  43.7
04EC:  GOTO   516
04ED:  MOVF   03,W
04EE:  XORLW  01
04EF:  MOVWF  03
04F0:  GOTO   516
04F1:  MOVF   40,W
04F2:  MOVWF  44
04F3:  MOVF   3C,W
04F4:  SUBWF  44,F
04F5:  BTFSC  03.2
04F6:  GOTO   4FD
04F7:  BTFSS  43.7
04F8:  GOTO   516
04F9:  MOVF   03,W
04FA:  XORLW  01
04FB:  MOVWF  03
04FC:  GOTO   516
04FD:  MOVF   41,W
04FE:  MOVWF  44
04FF:  MOVF   3D,W
0500:  SUBWF  44,F
0501:  BTFSC  03.2
0502:  GOTO   509
0503:  BTFSS  43.7
0504:  GOTO   516
0505:  MOVF   03,W
0506:  XORLW  01
0507:  MOVWF  03
0508:  GOTO   516
0509:  MOVF   42,W
050A:  MOVWF  44
050B:  MOVF   3E,W
050C:  SUBWF  44,F
050D:  BTFSC  03.2
050E:  GOTO   515
050F:  BTFSS  43.7
0510:  GOTO   516
0511:  MOVF   03,W
0512:  XORLW  01
0513:  MOVWF  03
0514:  GOTO   516
0515:  BCF    03.0
0516:  RETURN
0517:  MOVF   0B,W
0518:  MOVWF  3C
0519:  BCF    0B.7
051A:  BSF    03.5
051B:  BSF    03.6
051C:  BSF    0C.7
051D:  BSF    0C.0
051E:  NOP
051F:  NOP
0520:  BCF    03.5
0521:  BCF    03.6
0522:  BTFSC  3C.7
0523:  BSF    0B.7
0524:  BTFSC  03.0
0525:  GOTO   54E
0526:  BSF    03.6
0527:  MOVF   0C,W
0528:  ANDLW  7F
0529:  BCF    03.6
052A:  MOVWF  3C
052B:  BSF    03.6
052C:  MOVF   0D,W
052D:  BCF    03.6
052E:  MOVWF  3D
052F:  BSF    03.6
0530:  MOVF   0F,W
0531:  BCF    03.6
0532:  MOVWF  3E
0533:  MOVF   3C,W
0534:  MOVWF  48
0535:  CALL   10B
0536:  MOVF   3D,W
0537:  BSF    03.6
0538:  MOVWF  0D
0539:  BCF    03.6
053A:  MOVF   3E,W
053B:  BSF    03.6
053C:  MOVWF  0F
053D:  BCF    03.6
053E:  MOVF   0B,W
053F:  MOVWF  3F
0540:  BCF    0B.7
0541:  BSF    03.5
0542:  BSF    03.6
0543:  BSF    0C.7
0544:  BSF    0C.0
0545:  NOP
0546:  NOP
0547:  BCF    03.5
0548:  BCF    03.6
0549:  BTFSC  3F.7
054A:  BSF    0B.7
054B:  DECFSZ 3B,F
054C:  GOTO   54E
054D:  GOTO   56D
054E:  BSF    03.6
054F:  RLF    0C,W
0550:  RLF    0E,W
0551:  ANDLW  7F
0552:  BCF    03.6
0553:  MOVWF  3C
0554:  BSF    03.6
0555:  MOVF   0D,W
0556:  BCF    03.6
0557:  MOVWF  3D
0558:  BSF    03.6
0559:  MOVF   0F,W
055A:  BCF    03.6
055B:  MOVWF  3E
055C:  MOVF   3C,W
055D:  MOVWF  48
055E:  CALL   10B
055F:  MOVF   3D,W
0560:  BSF    03.6
0561:  MOVWF  0D
0562:  BCF    03.6
0563:  MOVF   3E,W
0564:  BSF    03.6
0565:  MOVWF  0F
0566:  INCF   0D,F
0567:  BTFSC  03.2
0568:  INCF   0F,F
0569:  BCF    03.0
056A:  BCF    03.6
056B:  DECFSZ 3B,F
056C:  GOTO   517
056D:  RETURN
056E:  BTFSC  03.1
056F:  GOTO   573
0570:  MOVLW  50
0571:  MOVWF  04
0572:  BCF    03.7
0573:  CLRF   77
0574:  CLRF   78
0575:  CLRF   79
0576:  CLRF   7A
0577:  CLRF   50
0578:  CLRF   51
0579:  CLRF   52
057A:  CLRF   53
057B:  MOVF   4F,W
057C:  IORWF  4E,W
057D:  IORWF  4D,W
057E:  IORWF  4C,W
057F:  BTFSC  03.2
0580:  GOTO   5B1
0581:  MOVLW  20
0582:  MOVWF  54
0583:  BCF    03.0
0584:  RLF    48,F
0585:  RLF    49,F
0586:  RLF    4A,F
0587:  RLF    4B,F
0588:  RLF    50,F
0589:  RLF    51,F
058A:  RLF    52,F
058B:  RLF    53,F
058C:  MOVF   4F,W
058D:  SUBWF  53,W
058E:  BTFSS  03.2
058F:  GOTO   59A
0590:  MOVF   4E,W
0591:  SUBWF  52,W
0592:  BTFSS  03.2
0593:  GOTO   59A
0594:  MOVF   4D,W
0595:  SUBWF  51,W
0596:  BTFSS  03.2
0597:  GOTO   59A
0598:  MOVF   4C,W
0599:  SUBWF  50,W
059A:  BTFSS  03.0
059B:  GOTO   5AB
059C:  MOVF   4C,W
059D:  SUBWF  50,F
059E:  MOVF   4D,W
059F:  BTFSS  03.0
05A0:  INCFSZ 4D,W
05A1:  SUBWF  51,F
05A2:  MOVF   4E,W
05A3:  BTFSS  03.0
05A4:  INCFSZ 4E,W
05A5:  SUBWF  52,F
05A6:  MOVF   4F,W
05A7:  BTFSS  03.0
05A8:  INCFSZ 4F,W
05A9:  SUBWF  53,F
05AA:  BSF    03.0
05AB:  RLF    77,F
05AC:  RLF    78,F
05AD:  RLF    79,F
05AE:  RLF    7A,F
05AF:  DECFSZ 54,F
05B0:  GOTO   583
05B1:  MOVF   50,W
05B2:  MOVWF  00
05B3:  INCF   04,F
05B4:  MOVF   51,W
05B5:  MOVWF  00
05B6:  INCF   04,F
05B7:  MOVF   52,W
05B8:  MOVWF  00
05B9:  INCF   04,F
05BA:  MOVF   53,W
05BB:  MOVWF  00
05BC:  RETURN
05BD:  MOVF   04,W
05BE:  MOVWF  40
05BF:  MOVF   3F,W
05C0:  MOVWF  42
05C1:  BTFSC  03.2
05C2:  GOTO   5DC
05C3:  MOVF   3E,W
05C4:  MOVWF  4B
05C5:  MOVF   3D,W
05C6:  MOVWF  4A
05C7:  MOVF   3C,W
05C8:  MOVWF  49
05C9:  MOVF   3B,W
05CA:  MOVWF  48
05CB:  CLRF   4F
05CC:  CLRF   4E
05CD:  MOVLW  20
05CE:  MOVWF  4D
05CF:  MOVLW  82
05D0:  MOVWF  4C
05D1:  CALL   18A
05D2:  MOVF   7A,W
05D3:  MOVWF  3E
05D4:  MOVF   79,W
05D5:  MOVWF  3D
05D6:  MOVF   78,W
05D7:  MOVWF  3C
05D8:  MOVF   77,W
05D9:  MOVWF  3B
05DA:  DECFSZ 42,F
05DB:  GOTO   5C3
05DC:  MOVF   3E,W
05DD:  MOVWF  4B
05DE:  MOVF   3D,W
05DF:  MOVWF  4A
05E0:  MOVF   3C,W
05E1:  MOVWF  49
05E2:  MOVF   3B,W
05E3:  MOVWF  48
05E4:  MOVF   48,W
05E5:  SUBLW  B6
05E6:  MOVWF  48
05E7:  CLRF   7A
05E8:  MOVF   49,W
05E9:  MOVWF  4C
05EA:  BSF    49.7
05EB:  BCF    03.0
05EC:  RRF    49,F
05ED:  RRF    4A,F
05EE:  RRF    4B,F
05EF:  RRF    7A,F
05F0:  RRF    79,F
05F1:  RRF    78,F
05F2:  RRF    77,F
05F3:  DECFSZ 48,F
05F4:  GOTO   5EB
05F5:  BTFSS  4C.7
05F6:  GOTO   602
05F7:  COMF   77,F
05F8:  COMF   78,F
05F9:  COMF   79,F
05FA:  COMF   7A,F
05FB:  INCF   77,F
05FC:  BTFSC  03.2
05FD:  INCF   78,F
05FE:  BTFSC  03.2
05FF:  INCF   79,F
0600:  BTFSC  03.2
0601:  INCF   7A,F
0602:  MOVF   7A,W
0603:  MOVWF  3E
0604:  MOVF   79,W
0605:  MOVWF  3D
0606:  MOVF   78,W
0607:  MOVWF  3C
0608:  MOVF   77,W
0609:  MOVWF  3B
060A:  BTFSS  3E.7
060B:  GOTO   619
060C:  DECF   40,F
060D:  BSF    40.5
060E:  COMF   3B,F
060F:  COMF   3C,F
0610:  COMF   3D,F
0611:  COMF   3E,F
0612:  INCF   3B,F
0613:  BTFSC  03.2
0614:  INCF   3C,F
0615:  BTFSC  03.2
0616:  INCF   3D,F
0617:  BTFSC  03.2
0618:  INCF   3E,F
0619:  MOVLW  3B
061A:  MOVWF  47
061B:  MOVLW  9A
061C:  MOVWF  46
061D:  MOVLW  CA
061E:  MOVWF  45
061F:  CLRF   44
0620:  MOVLW  0A
0621:  MOVWF  42
0622:  MOVF   3F,W
0623:  BTFSC  03.2
0624:  INCF   40,F
0625:  BSF    03.1
0626:  MOVLW  3B
0627:  MOVWF  04
0628:  BCF    03.7
0629:  MOVF   3E,W
062A:  MOVWF  4B
062B:  MOVF   3D,W
062C:  MOVWF  4A
062D:  MOVF   3C,W
062E:  MOVWF  49
062F:  MOVF   3B,W
0630:  MOVWF  48
0631:  MOVF   47,W
0632:  MOVWF  4F
0633:  MOVF   46,W
0634:  MOVWF  4E
0635:  MOVF   45,W
0636:  MOVWF  4D
0637:  MOVF   44,W
0638:  MOVWF  4C
0639:  CALL   56E
063A:  MOVF   78,W
063B:  MOVF   77,F
063C:  BTFSS  03.2
063D:  GOTO   651
063E:  INCF   3F,W
063F:  SUBWF  42,W
0640:  BTFSC  03.2
0641:  GOTO   651
0642:  MOVF   40,W
0643:  BTFSC  03.2
0644:  GOTO   653
0645:  ANDLW  0F
0646:  SUBWF  42,W
0647:  BTFSC  03.2
0648:  GOTO   64B
0649:  BTFSC  03.0
064A:  GOTO   683
064B:  BTFSC  40.7
064C:  GOTO   683
064D:  BTFSC  40.6
064E:  GOTO   653
064F:  MOVLW  20
0650:  GOTO   67F
0651:  MOVLW  20
0652:  ANDWF  40,F
0653:  BTFSS  40.5
0654:  GOTO   661
0655:  BCF    40.5
0656:  MOVF   3F,W
0657:  BTFSS  03.2
0658:  DECF   40,F
0659:  MOVF   77,W
065A:  MOVWF  40
065B:  MOVLW  2D
065C:  MOVWF  48
065D:  CALL   10B
065E:  MOVF   40,W
065F:  MOVWF  77
0660:  CLRF   40
0661:  MOVF   3F,W
0662:  SUBWF  42,W
0663:  BTFSS  03.2
0664:  GOTO   66F
0665:  MOVF   77,W
0666:  MOVWF  40
0667:  MOVLW  2E
0668:  MOVWF  48
0669:  CALL   10B
066A:  MOVF   40,W
066B:  MOVWF  77
066C:  MOVLW  20
066D:  ANDWF  40,F
066E:  MOVLW  00
066F:  MOVLW  30
0670:  BTFSS  40.5
0671:  GOTO   67F
0672:  BCF    40.5
0673:  MOVF   3F,W
0674:  BTFSS  03.2
0675:  DECF   40,F
0676:  MOVF   77,W
0677:  MOVWF  40
0678:  MOVLW  2D
0679:  MOVWF  48
067A:  CALL   10B
067B:  MOVF   40,W
067C:  MOVWF  77
067D:  CLRF   40
067E:  MOVLW  30
067F:  ADDWF  77,F
0680:  MOVF   77,W
0681:  MOVWF  48
0682:  CALL   10B
0683:  BCF    03.1
0684:  MOVF   47,W
0685:  MOVWF  4B
0686:  MOVF   46,W
0687:  MOVWF  4A
0688:  MOVF   45,W
0689:  MOVWF  49
068A:  MOVF   44,W
068B:  MOVWF  48
068C:  CLRF   4F
068D:  CLRF   4E
068E:  CLRF   4D
068F:  MOVLW  0A
0690:  MOVWF  4C
0691:  CALL   56E
0692:  MOVF   7A,W
0693:  MOVWF  47
0694:  MOVF   79,W
0695:  MOVWF  46
0696:  MOVF   78,W
0697:  MOVWF  45
0698:  MOVF   77,W
0699:  MOVWF  44
069A:  DECFSZ 42,F
069B:  GOTO   625
069C:  RETURN
....................  
.................... #list 
....................  
.................... #include <def_16f877a.h> 
.................... // register definitions 
....................  
.................... #define W 0 
.................... #define F 1 
....................  
.................... // register files 
.................... #byte INDF          =0x00 
.................... #byte TMR0          =0x01 
.................... #byte PCL           =0x02 
.................... #byte STATUS        =0x03 
.................... #byte FSR           =0x04 
.................... #byte PORTA         =0x05 
.................... #byte PORTB         =0x06 
.................... #byte PORTC         =0x07 
.................... #byte PORTD         =0x08 
.................... #byte PORTE         =0x09 
....................  
.................... #byte EEDATA        =0x10C 
.................... #byte EEADR         =0x10D 
.................... #byte EEDATH        =0x10E 
.................... #byte EEADRH         =0x10F 
.................... #byte ADCON0 	 =0x1F 
.................... #byte ADCON1 	 =0x9F 
.................... #byte ADRESH 	 =0x9F 
.................... #byte ADSESL 	 =0x9F 
....................  
.................... #byte PCLATH        =0x0a 
.................... #byte INTCON        =0x0b 
.................... #byte PIR1 	=0x0c 
.................... #byte PIR2 	=0x0d 
.................... #byte PIE1 	=0x8c 
.................... #byte PIE2 	=0x8d 
....................  
.................... #byte OPTION_REG    =0x81 
.................... #byte TRISA         =0x85 
.................... #byte TRISB         =0x86 
.................... #byte TRISC         =0x87 
.................... #byte TRISD         =0x88 
.................... #byte TRISE         =0x89 
....................  
.................... #byte EECON1        =0x18C 
.................... #byte EECON2        =0x18D 
....................  
.................... //DINH NGHIA BIT 
.................... #bit RA5	=0x05.5 
.................... #bit RA4	=0x05.4 
.................... #bit RA3	=0x05.3 
.................... #bit RA2	=0x05.2 
.................... #bit RA1	=0x05.1 
.................... #bit RA0	=0x05.0 
....................  
.................... #bit RB7	=0x06.7 
.................... #bit RB6	=0x06.6 
.................... #bit RB5	=0x06.5 
.................... #bit RB4	=0x06.4 
.................... #bit RB3	=0x06.3 
.................... #bit RB2	=0x06.2 
.................... #bit RB1	=0x06.1 
.................... #bit RB0	=0x06.0 
....................  
.................... #bit RC7	=0x07.7 
.................... #bit RC6	=0x07.6 
.................... #bit RC5	=0x07.5 
.................... #bit RC4	=0x07.4 
.................... #bit RC3	=0x07.3 
.................... #bit RC2	=0x07.2 
.................... #bit RC1	=0x07.1 
.................... #bit RC0	=0x07.0 
....................  
.................... #bit RD7	=0x08.7 
.................... #bit RD6	=0x08.6 
.................... #bit RD5	=0x08.5 
.................... #bit RD4	=0x08.4 
.................... #bit RD3	=0x08.3 
.................... #bit RD2	=0x08.2 
.................... #bit RD1	=0x08.1 
.................... #bit RD0	=0x08.0 
....................  
.................... #bit RE2	=0x09.2 
.................... #bit RE1	=0x09.1 
.................... #bit RE0	=0x09.0 
....................  
....................  
.................... #bit TRISA5	=0x85.5 
.................... #bit TRISA4	=0x85.4 
.................... #bit TRISA3	=0x85.3 
.................... #bit TRISA2	=0x85.2 
.................... #bit TRISA1	=0x85.1 
.................... #bit TRISA0	=0x85.0 
....................  
.................... #bit TRISB7	=0x86.7 
.................... #bit TRISB6	=0x86.6 
.................... #bit TRISB5	=0x86.5 
.................... #bit TRISB4	=0x86.4 
.................... #bit TRISB3	=0x86.3 
.................... #bit TRISB2	=0x86.2 
.................... #bit TRISB1	=0x86.1 
.................... #bit TRISB0	=0x86.0 
....................  
.................... #bit TRISC7	=0x87.7 
.................... #bit TRISC6	=0x87.6 
.................... #bit TRISC5	=0x87.5 
.................... #bit TRISC4	=0x87.4 
.................... #bit TRISC3	=0x87.3 
.................... #bit TRISC2	=0x87.2 
.................... #bit TRISC1	=0x87.1 
.................... #bit TRISC0	=0x87.0 
....................  
.................... #bit TRISD7	=0x88.7 
.................... #bit TRISD6	=0x88.6 
.................... #bit TRISD5	=0x88.5 
.................... #bit TRISD4	=0x88.4 
.................... #bit TRISD3	=0x88.3 
.................... #bit TRISD2	=0x88.2 
.................... #bit TRISD1	=0x88.1 
.................... #bit TRISD0	=0x88.0 
....................  
.................... #bit TRISE2	=0x89.2 
.................... #bit TRISE1	=0x89.1 
.................... #bit TRISE0	=0x89.0 
....................  
.................... // INTCON Bits for C 
.................... #bit gie 	= 0x0b.7 
.................... #bit peie = 0x0b.6 
.................... #bit tmr0ie = 0x0b.5 
.................... #bit int0ie = 0x0b.4 
.................... #bit rbie	= 0x0b.3 
.................... #bit tmr0if    = 0x0b.2 
.................... #bit int0if    = 0x0b.1 
.................... #bit rbif    = 0x0b.0 
....................  
.................... // PIR1 for C 
.................... #bit pspif  = 0x0c.7 
.................... #bit adif    = 0x0c.6 
.................... #bit rcif    = 0x0c.5 
.................... #bit txif    = 0x0c.4 
.................... #bit sspif    = 0x0c.3 
.................... #bit ccp1if    = 0x0c.2 
.................... #bit tmr2if    = 0x0c.1 
.................... #bit tmr1if    = 0x0c.0 
....................  
.................... //PIR2 for C 
.................... #bit cmif    = 0x0d.6 
.................... #bit eeif    = 0x0d.4 
.................... #bit bclif  = 0x0d.3 
.................... #bit ccp2if    = 0x0d.0 
....................  
.................... // PIE1 for C 
.................... #bit adie    = 0x8c.6 
.................... #bit rcie    = 0x8c.5 
.................... #bit txie    = 0x8c.4 
.................... #bit sspie    = 0x8c.3 
.................... #bit ccp1ie    = 0x8c.2 
.................... #bit tmr2ie    = 0x8c.1 
.................... #bit tmr1ie    = 0x8c.0 
....................  
.................... //PIE2 for C 
.................... #bit osfie    = 0x8d.7 
.................... #bit cmie    = 0x8d.6 
.................... #bit eeie	= 0x8d.4 
....................  
.................... // OPTION Bits 
.................... #bit not_rbpu	= 0x81.7 
.................... #bit intedg     = 0x81.6 
.................... #bit t0cs       = 0x81.5 
.................... #bit t0se       = 0x81.4 
.................... #bit psa        = 0x81.3 
.................... #bit ps2        = 0x81.2 
.................... #bit ps1        = 0x81.1 
.................... #bit ps0        = 0x81.0 
....................  
.................... // EECON1 Bits 
.................... #bit eepgd	= 0x18c.7 
.................... #bit free   	= 0x18C.4 
.................... #bit wrerr  	= 0x18C.3 
.................... #bit wren    	= 0x18C.2 
.................... #bit wr      	= 0x18C.1 
.................... #bit rd      	= 0x18C.0 
....................  
.................... //ADCON0 
.................... #bit CHS0 	=0x1F.3 
.................... #bit CHS1 	=0x1F.4 
.................... #bit CHS2 	=0x1F.5 
....................  
.................... #device *=16 adc=10 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0813:  BCF    03.5
0814:  CLRF   20
0815:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #FUSES NOWDT, HS, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT 
.................... #use delay(clock=20000000) 
*
00B9:  MOVLW  4A
00BA:  MOVWF  04
00BB:  BCF    03.7
00BC:  MOVF   00,W
00BD:  BTFSC  03.2
00BE:  GOTO   0CC
00BF:  MOVLW  06
00C0:  MOVWF  78
00C1:  CLRF   77
00C2:  DECFSZ 77,F
00C3:  GOTO   0C2
00C4:  DECFSZ 78,F
00C5:  GOTO   0C1
00C6:  MOVLW  7B
00C7:  MOVWF  77
00C8:  DECFSZ 77,F
00C9:  GOTO   0C8
00CA:  DECFSZ 00,F
00CB:  GOTO   0BF
00CC:  RETURN
....................  
.................... #include <lcd_lib_4bit.c> 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... #define LCD_ENABLE_PIN PIN_B2 
.................... #define LCD_RS_PIN PIN_B0 
.................... #define LCD_RW_PIN PIN_B1 
.................... #define LCD_DATA4 PIN_B4 
.................... #define LCD_DATA5 PIN_B5 
.................... #define LCD_DATA6 PIN_B6 
.................... #define LCD_DATA7 PIN_B7                                  
.................... #define Line_1          0x80 
.................... #define Line_2          0xC0 
.................... #define Line_3          0x94 
.................... #define Line_4          0xD4 
.................... #define Clear_Scr       0x01 
....................  
.................... // prototype statements 
.................... #separate void LCD_Init (void);// ham khoi tao LCD 
.................... #separate void LCD_SetPosition (unsigned int cX);//Thiet lap vi tri con tro 
.................... #separate void LCD_PutChar (unsigned int cX);// Ham viet1kitu/1chuoi len LCD 
.................... #separate void LCD_PutCmd (unsigned int cX) ;// Ham gui lenh len LCD 
.................... #separate void LCD_PulseEnable (void);// Xung kich hoat 
.................... #separate void LCD_SetData (unsigned int cX);// Dat du lieu len chan Data 
.................... // D/n Cong 
.................... #use standard_io (C) 
.................... #use standard_io (D) 
....................  
.................... //khoi tao LCD********************************************** 
.................... #separate void LCD_Init ( void ) 
.................... { 
.................... LCD_SetData ( 0x00 ); 
*
00E9:  CLRF   4A
00EA:  CALL   098
.................... delay_ms(200);       /* wait enough time after Vdd rise >> 15ms */ 
00EB:  MOVLW  C8
00EC:  MOVWF  4A
00ED:  CALL   0B9
.................... output_low ( LCD_RS_PIN );// che do gui lenh 
00EE:  BSF    03.5
00EF:  BCF    06.0
00F0:  BCF    03.5
00F1:  BCF    06.0
.................... LCD_SetData ( 0x03 );   /* init with specific nibbles to start 4-bit mode */ 
00F2:  MOVLW  03
00F3:  MOVWF  4A
00F4:  CALL   098
.................... LCD_PulseEnable(); 
00F5:  CALL   0CD
.................... LCD_PulseEnable(); 
00F6:  CALL   0CD
.................... LCD_PulseEnable(); 
00F7:  CALL   0CD
.................... LCD_SetData ( 0x02 );   /* set 4-bit interface */ 
00F8:  MOVLW  02
00F9:  MOVWF  4A
00FA:  CALL   098
.................... LCD_PulseEnable();      /* send dual nibbles hereafter, MSN first */ 
00FB:  CALL   0CD
.................... LCD_PutCmd ( 0x2C );    /* function set (all lines, 5x7 characters) */ 
00FC:  MOVLW  2C
00FD:  MOVWF  49
00FE:  CALL   0DE
.................... LCD_PutCmd ( 0x0C );    /* display ON, cursor off, no blink */ 
00FF:  MOVLW  0C
0100:  MOVWF  49
0101:  CALL   0DE
.................... LCD_PutCmd ( 0x06 );    /* entry mode set, increment & scroll left */ 
0102:  MOVLW  06
0103:  MOVWF  49
0104:  CALL   0DE
.................... LCD_PutCmd ( 0x01 );    /* clear display */ 
0105:  MOVLW  01
0106:  MOVWF  49
0107:  CALL   0DE
0108:  BSF    0A.3
0109:  BCF    0A.4
010A:  GOTO   01F (RETURN)
.................... } 
....................  
.................... #separate void LCD_SetPosition ( unsigned int cX ) 
.................... { 
.................... /* this subroutine works specifically for 4-bit Port A */ 
.................... LCD_SetData ( swap ( cX ) | 0x08 ); 
.................... LCD_PulseEnable(); 
.................... LCD_SetData ( swap ( cX ) ); 
.................... LCD_PulseEnable(); 
.................... } 
....................  
.................... #separate void LCD_PutChar ( unsigned int cX ) 
.................... { 
.................... /* this subroutine works specifically for 4-bit Port A */ 
.................... output_high ( LCD_RS_PIN ); 
010B:  BSF    03.5
010C:  BCF    06.0
010D:  BCF    03.5
010E:  BSF    06.0
.................... LCD_PutCmd( cX ); 
010F:  MOVF   48,W
0110:  MOVWF  49
0111:  CALL   0DE
.................... output_low ( LCD_RS_PIN ); 
0112:  BSF    03.5
0113:  BCF    06.0
0114:  BCF    03.5
0115:  BCF    06.0
0116:  RETURN
.................... } 
....................  
.................... #separate void LCD_PutCmd ( unsigned int cX ) 
.................... { 
.................... /* this subroutine works specifically for 4-bit Port A */ 
.................... LCD_SetData ( swap ( cX ) );     /* send high nibble */ 
*
00DE:  SWAPF  49,F
00DF:  MOVF   49,W
00E0:  MOVWF  4A
00E1:  CALL   098
.................... LCD_PulseEnable(); 
00E2:  CALL   0CD
.................... LCD_SetData ( swap ( cX ) );     /* send low nibble */ 
00E3:  SWAPF  49,F
00E4:  MOVF   49,W
00E5:  MOVWF  4A
00E6:  CALL   098
.................... LCD_PulseEnable(); 
00E7:  CALL   0CD
00E8:  RETURN
.................... } 
.................... #separate void LCD_PulseEnable ( void ) 
.................... { 
.................... output_high ( LCD_ENABLE_PIN ); 
*
00CD:  BSF    03.5
00CE:  BCF    06.2
00CF:  BCF    03.5
00D0:  BSF    06.2
.................... delay_us ( 3 );         // was 10 
00D1:  MOVLW  04
00D2:  MOVWF  77
00D3:  DECFSZ 77,F
00D4:  GOTO   0D3
00D5:  GOTO   0D6
.................... output_low ( LCD_ENABLE_PIN ); 
00D6:  BSF    03.5
00D7:  BCF    06.2
00D8:  BCF    03.5
00D9:  BCF    06.2
.................... delay_ms ( 3 );         // was 5 
00DA:  MOVLW  03
00DB:  MOVWF  4A
00DC:  CALL   0B9
00DD:  RETURN
.................... } 
....................  
.................... #separate void LCD_SetData ( unsigned int cX ) 
.................... { 
.................... output_bit ( LCD_DATA4, cX & 0x01 ); 
*
0098:  BTFSC  4A.0
0099:  GOTO   09C
009A:  BCF    06.4
009B:  GOTO   09D
009C:  BSF    06.4
009D:  BSF    03.5
009E:  BCF    06.4
.................... output_bit ( LCD_DATA5, cX & 0x02 ); 
009F:  BCF    03.5
00A0:  BTFSC  4A.1
00A1:  GOTO   0A4
00A2:  BCF    06.5
00A3:  GOTO   0A5
00A4:  BSF    06.5
00A5:  BSF    03.5
00A6:  BCF    06.5
.................... output_bit ( LCD_DATA6, cX & 0x04 ); 
00A7:  BCF    03.5
00A8:  BTFSC  4A.2
00A9:  GOTO   0AC
00AA:  BCF    06.6
00AB:  GOTO   0AD
00AC:  BSF    06.6
00AD:  BSF    03.5
00AE:  BCF    06.6
.................... output_bit ( LCD_DATA7, cX & 0x08 ); 
00AF:  BCF    03.5
00B0:  BTFSC  4A.3
00B1:  GOTO   0B4
00B2:  BCF    06.7
00B3:  GOTO   0B5
00B4:  BSF    06.7
00B5:  BSF    03.5
00B6:  BCF    06.7
00B7:  BCF    03.5
00B8:  RETURN
.................... } 
....................  
....................  
.................... #DEFINE RW RB1 
....................  
.................... #define LAMP PIN_D4 
.................... #define DC   PIN_D5 
.................... #define MB   PIN_D6 
....................  
.................... #define button1 PIN_C0 
.................... #define button2 PIN_C1 
.................... #define button3 PIN_C2 
.................... #define SW PIN_C3 
....................  
....................  
.................... int button_tt1 = 0, button_tt2 = 0, button_tt3 = 0; 
.................... unsigned int8 bien1 = 0, bien2 = 0, bien3 = 0; 
.................... unsigned int16 adc_value1, adc_value2, adc_value3; 
.................... float humidity, Inte, Temp; 
....................  
....................  
.................... void Doc_ADC() 
.................... { 
....................   set_adc_channel(0);//Chon Kenh ADC AN0 
*
02C9:  MOVLW  00
02CA:  MOVWF  78
02CB:  MOVF   1F,W
02CC:  ANDLW  C7
02CD:  IORWF  78,W
02CE:  MOVWF  1F
....................   delay_us(20);//Tre toi thieu 20us de gia tri lay mau dung. 
02CF:  MOVLW  20
02D0:  MOVWF  77
02D1:  DECFSZ 77,F
02D2:  GOTO   2D1
02D3:  GOTO   2D4
02D4:  NOP
....................   adc_value1=read_adc(); 
02D5:  BSF    1F.2
02D6:  BTFSC  1F.2
02D7:  GOTO   2D6
02D8:  BSF    03.5
02D9:  MOVF   1E,W
02DA:  BCF    03.5
02DB:  MOVWF  29
02DC:  MOVF   1E,W
02DD:  MOVWF  2A
....................   Temp=(float)((adc_value1*1023.0)/2046.0 ); 
02DE:  MOVF   2A,W
02DF:  MOVWF  3C
02E0:  MOVF   29,W
02E1:  MOVWF  3B
02E2:  CALL   16D
02E3:  MOVF   7A,W
02E4:  MOVWF  4B
02E5:  MOVF   79,W
02E6:  MOVWF  4A
02E7:  MOVF   78,W
02E8:  MOVWF  49
02E9:  MOVF   77,W
02EA:  MOVWF  48
02EB:  CLRF   4F
02EC:  MOVLW  C0
02ED:  MOVWF  4E
02EE:  MOVLW  7F
02EF:  MOVWF  4D
02F0:  MOVLW  88
02F1:  MOVWF  4C
02F2:  CALL   18A
02F3:  MOVF   7A,W
02F4:  MOVWF  3E
02F5:  MOVF   79,W
02F6:  MOVWF  3D
02F7:  MOVF   78,W
02F8:  MOVWF  3C
02F9:  MOVF   77,W
02FA:  MOVWF  3B
02FB:  MOVF   7A,W
02FC:  MOVWF  42
02FD:  MOVF   79,W
02FE:  MOVWF  41
02FF:  MOVF   78,W
0300:  MOVWF  40
0301:  MOVF   77,W
0302:  MOVWF  3F
0303:  CLRF   46
0304:  MOVLW  C0
0305:  MOVWF  45
0306:  MOVLW  7F
0307:  MOVWF  44
0308:  MOVLW  89
0309:  MOVWF  43
030A:  CALL   1FF
030B:  MOVF   7A,W
030C:  MOVWF  3A
030D:  MOVF   79,W
030E:  MOVWF  39
030F:  MOVF   78,W
0310:  MOVWF  38
0311:  MOVF   77,W
0312:  MOVWF  37
....................  
....................   set_adc_channel(1);//Chon Kenh ADC AN1 
0313:  MOVLW  08
0314:  MOVWF  78
0315:  MOVF   1F,W
0316:  ANDLW  C7
0317:  IORWF  78,W
0318:  MOVWF  1F
....................   delay_us(20);//Tre toi thieu 20us de gia tri lay mau dung. 
0319:  MOVLW  20
031A:  MOVWF  77
031B:  DECFSZ 77,F
031C:  GOTO   31B
031D:  GOTO   31E
031E:  NOP
....................   adc_value2 = read_adc(); 
031F:  BSF    1F.2
0320:  BTFSC  1F.2
0321:  GOTO   320
0322:  BSF    03.5
0323:  MOVF   1E,W
0324:  BCF    03.5
0325:  MOVWF  2B
0326:  MOVF   1E,W
0327:  MOVWF  2C
....................   humidity = 100.0 - ((float)adc_value2 * 100.0/1023.0); 
0328:  MOVF   2C,W
0329:  MOVWF  3C
032A:  MOVF   2B,W
032B:  MOVWF  3B
032C:  CALL   16D
032D:  MOVF   7A,W
032E:  MOVWF  3E
032F:  MOVF   79,W
0330:  MOVWF  3D
0331:  MOVF   78,W
0332:  MOVWF  3C
0333:  MOVF   77,W
0334:  MOVWF  3B
0335:  MOVF   3E,W
0336:  MOVWF  4B
0337:  MOVF   3D,W
0338:  MOVWF  4A
0339:  MOVF   3C,W
033A:  MOVWF  49
033B:  MOVF   3B,W
033C:  MOVWF  48
033D:  CLRF   4F
033E:  CLRF   4E
033F:  MOVLW  48
0340:  MOVWF  4D
0341:  MOVLW  85
0342:  MOVWF  4C
0343:  CALL   18A
0344:  MOVF   7A,W
0345:  MOVWF  3E
0346:  MOVF   79,W
0347:  MOVWF  3D
0348:  MOVF   78,W
0349:  MOVWF  3C
034A:  MOVF   77,W
034B:  MOVWF  3B
034C:  MOVF   3E,W
034D:  MOVWF  42
034E:  MOVF   3D,W
034F:  MOVWF  41
0350:  MOVF   3C,W
0351:  MOVWF  40
0352:  MOVF   3B,W
0353:  MOVWF  3F
0354:  CLRF   46
0355:  MOVLW  C0
0356:  MOVWF  45
0357:  MOVLW  7F
0358:  MOVWF  44
0359:  MOVLW  88
035A:  MOVWF  43
035B:  CALL   1FF
035C:  BSF    03.1
035D:  CLRF   3E
035E:  CLRF   3D
035F:  MOVLW  48
0360:  MOVWF  3C
0361:  MOVLW  85
0362:  MOVWF  3B
0363:  MOVF   7A,W
0364:  MOVWF  42
0365:  MOVF   79,W
0366:  MOVWF  41
0367:  MOVF   78,W
0368:  MOVWF  40
0369:  MOVF   77,W
036A:  MOVWF  3F
*
04AB:  MOVF   7A,W
04AC:  MOVWF  32
04AD:  MOVF   79,W
04AE:  MOVWF  31
04AF:  MOVF   78,W
04B0:  MOVWF  30
04B1:  MOVF   77,W
04B2:  MOVWF  2F
....................  
....................   set_adc_channel(2);//Chon Kenh ADC AN2 
04B3:  MOVLW  10
04B4:  MOVWF  78
04B5:  MOVF   1F,W
04B6:  ANDLW  C7
04B7:  IORWF  78,W
04B8:  MOVWF  1F
....................   delay_us(20);//Tre toi thieu 20us de gia tri lay mau dung. 
04B9:  MOVLW  20
04BA:  MOVWF  77
04BB:  DECFSZ 77,F
04BC:  GOTO   4BB
04BD:  GOTO   4BE
04BE:  NOP
....................   adc_value3=read_adc(); 
04BF:  BSF    1F.2
04C0:  BTFSC  1F.2
04C1:  GOTO   4C0
04C2:  BSF    03.5
04C3:  MOVF   1E,W
04C4:  BCF    03.5
04C5:  MOVWF  2D
04C6:  MOVF   1E,W
04C7:  MOVWF  2E
....................   Inte=(float)(adc_value3); 
04C8:  MOVF   2E,W
04C9:  MOVWF  3C
04CA:  MOVF   2D,W
04CB:  MOVWF  3B
04CC:  CALL   16D
04CD:  MOVF   7A,W
04CE:  MOVWF  36
04CF:  MOVF   79,W
04D0:  MOVWF  35
04D1:  MOVF   78,W
04D2:  MOVWF  34
04D3:  MOVF   77,W
04D4:  MOVWF  33
04D5:  BSF    0A.3
04D6:  BCF    0A.4
04D7:  GOTO   1AD (RETURN)
.................... } 
....................  
.................... void main() 
*
0800:  MOVF   03,W
0801:  ANDLW  1F
0802:  MOVWF  03
0803:  MOVLW  FF
0804:  MOVWF  22
0805:  CLRF   23
0806:  CLRF   24
0807:  CLRF   25
0808:  CLRF   26
0809:  CLRF   27
080A:  CLRF   28
080B:  BSF    03.5
080C:  BSF    1F.0
080D:  BSF    1F.1
080E:  BSF    1F.2
080F:  BCF    1F.3
0810:  MOVLW  07
0811:  MOVWF  1C
0812:  BCF    03.7
.................... { 
.................... RW=0; 
*
0816:  BCF    06.1
....................    trisb = 0x00; 
0817:  BSF    03.5
0818:  CLRF   06
....................    trisc = 0xff; 
0819:  MOVLW  FF
081A:  MOVWF  07
....................    trisd = 0x00; 
081B:  CLRF   08
....................  
....................    LCD_init();     
081C:  BCF    0A.3
081D:  BCF    03.5
081E:  GOTO   0E9
081F:  BSF    0A.3
....................    setup_adc(ADC_CLOCK_DIV_16); 
0820:  BSF    03.5
0821:  BSF    1F.6
0822:  BCF    03.5
0823:  BSF    1F.6
0824:  BCF    1F.7
0825:  BSF    03.5
0826:  BSF    1F.7
0827:  BCF    03.5
0828:  BSF    1F.0
....................    setup_adc_ports(AN0_AN1_AN2_AN3_AN4_AN5); 
0829:  BSF    03.5
082A:  BSF    1F.0
082B:  BCF    1F.1
082C:  BCF    1F.2
082D:  BSF    1F.3
....................     
....................       while (true) 
....................          { 
....................          
....................          switch(input(SW)) 
082E:  BCF    03.5
082F:  BSF    22.3
0830:  MOVF   22,W
0831:  BSF    03.5
0832:  MOVWF  07
0833:  MOVLW  00
0834:  BCF    03.5
0835:  BTFSC  07.3
0836:  MOVLW  01
0837:  XORLW  00
0838:  BTFSC  03.2
0839:  GOTO   03E
083A:  XORLW  01
083B:  BTFSC  03.2
083C:  GOTO   19D
083D:  GOTO   311
....................          { 
....................             case 0: 
....................              
....................             LCD_putcmd(0x80); 
083E:  MOVLW  80
083F:  MOVWF  49
0840:  BCF    0A.3
0841:  CALL   0DE
0842:  BSF    0A.3
....................             Printf(LCD_putchar,"Active Mode: Manual"); 
0843:  MOVLW  04
0844:  BSF    03.6
0845:  MOVWF  0D
0846:  MOVLW  00
0847:  MOVWF  0F
0848:  BCF    0A.3
0849:  BCF    03.6
084A:  CALL   117
084B:  BSF    0A.3
....................              
....................             if(input(button1) == 0 && button_tt1 == 0) //N?u nút nh?n du?c nh?n l?n 1 
084C:  BSF    22.0
084D:  MOVF   22,W
084E:  BSF    03.5
084F:  MOVWF  07
0850:  BCF    03.5
0851:  BTFSC  07.0
0852:  GOTO   06D
0853:  MOVF   23,F
0854:  BTFSS  03.2
0855:  GOTO   06D
....................             { 
....................                while(input(button1) == 0 && button_tt1 == 0); 
0856:  BSF    22.0
0857:  MOVF   22,W
0858:  BSF    03.5
0859:  MOVWF  07
085A:  BCF    03.5
085B:  BTFSC  07.0
085C:  GOTO   060
085D:  MOVF   23,F
085E:  BTFSC  03.2
085F:  GOTO   056
....................                delay_ms(50) ; 
0860:  MOVLW  32
0861:  MOVWF  4A
0862:  BCF    0A.3
0863:  CALL   0B9
0864:  BSF    0A.3
....................                button_tt1 = 1; //C?p nh?t tr?ng thái c?a nút nh?n 
0865:  MOVLW  01
0866:  MOVWF  23
....................                output_high (MB); //B?t dèn LED 
0867:  BSF    03.5
0868:  BCF    08.6
0869:  BCF    03.5
086A:  BSF    08.6
....................                bien1 = 1; 
086B:  MOVWF  26
....................             } 
086C:  GOTO   088
....................     
....................             else if(input (button1) == 0 && button_tt1 == 1) //N?u nút nh?n du?c nh?n l?n 2 
086D:  BSF    22.0
086E:  MOVF   22,W
086F:  BSF    03.5
0870:  MOVWF  07
0871:  BCF    03.5
0872:  BTFSC  07.0
0873:  GOTO   088
0874:  DECFSZ 23,W
0875:  GOTO   088
....................             { 
....................                while(input (button1) == 1); 
0876:  BSF    22.0
0877:  MOVF   22,W
0878:  BSF    03.5
0879:  MOVWF  07
087A:  BCF    03.5
087B:  BTFSC  07.0
087C:  GOTO   076
....................                delay_ms (50) ; 
087D:  MOVLW  32
087E:  MOVWF  4A
087F:  BCF    0A.3
0880:  CALL   0B9
0881:  BSF    0A.3
....................                button_tt1 = 0; //C?p nh?t tr?ng thái c?a nút nh?n 
0882:  CLRF   23
....................                output_low (MB); //T?t dèn LED 
0883:  BSF    03.5
0884:  BCF    08.6
0885:  BCF    03.5
0886:  BCF    08.6
....................                bien1 = 0; 
0887:  CLRF   26
....................             } 
....................         
....................             if(bien1 == 1) 
0888:  DECFSZ 26,W
0889:  GOTO   0A2
....................             { 
....................                LCD_putcmd(0xC0); 
088A:  MOVLW  C0
088B:  MOVWF  49
088C:  BCF    0A.3
088D:  CALL   0DE
088E:  BSF    0A.3
....................                delay_ms (50); 
088F:  MOVLW  32
0890:  MOVWF  4A
0891:  BCF    0A.3
0892:  CALL   0B9
0893:  BSF    0A.3
....................                Printf(LCD_putchar,"TB1:1   Temp:OFF    "); 
0894:  MOVLW  0E
0895:  BSF    03.6
0896:  MOVWF  0D
0897:  MOVLW  00
0898:  MOVWF  0F
0899:  BCF    0A.3
089A:  BCF    03.6
089B:  CALL   117
089C:  BSF    0A.3
....................                output_high(MB); //bat dèn LED 
089D:  BSF    03.5
089E:  BCF    08.6
089F:  BCF    03.5
08A0:  BSF    08.6
....................              }  
08A1:  GOTO   0BC
....................             else if(bien1 == 0){ 
08A2:  MOVF   26,F
08A3:  BTFSS  03.2
08A4:  GOTO   0BC
....................                LCD_putcmd(0xC0); 
08A5:  MOVLW  C0
08A6:  MOVWF  49
08A7:  BCF    0A.3
08A8:  CALL   0DE
08A9:  BSF    0A.3
....................                delay_ms (50); 
08AA:  MOVLW  32
08AB:  MOVWF  4A
08AC:  BCF    0A.3
08AD:  CALL   0B9
08AE:  BSF    0A.3
....................                Printf(LCD_putchar,"TB1:0   Temp:OFF    "); 
08AF:  MOVLW  19
08B0:  BSF    03.6
08B1:  MOVWF  0D
08B2:  MOVLW  00
08B3:  MOVWF  0F
08B4:  BCF    0A.3
08B5:  BCF    03.6
08B6:  CALL   117
08B7:  BSF    0A.3
....................                output_low(MB); //tat den LED 
08B8:  BSF    03.5
08B9:  BCF    08.6
08BA:  BCF    03.5
08BB:  BCF    08.6
....................             } 
....................             
....................             // TTHIET BI 2 
....................             if(input (button2) == 0 && button_tt2 == 0) //N?u nút nh?n du?c nh?n l?n 1 
08BC:  BSF    22.1
08BD:  MOVF   22,W
08BE:  BSF    03.5
08BF:  MOVWF  07
08C0:  BCF    03.5
08C1:  BTFSC  07.1
08C2:  GOTO   0DD
08C3:  MOVF   24,F
08C4:  BTFSS  03.2
08C5:  GOTO   0DD
....................             { 
....................                while(input (button2) == 0 && button_tt2 == 0); 
08C6:  BSF    22.1
08C7:  MOVF   22,W
08C8:  BSF    03.5
08C9:  MOVWF  07
08CA:  BCF    03.5
08CB:  BTFSC  07.1
08CC:  GOTO   0D0
08CD:  MOVF   24,F
08CE:  BTFSC  03.2
08CF:  GOTO   0C6
....................                delay_ms (50) ; 
08D0:  MOVLW  32
08D1:  MOVWF  4A
08D2:  BCF    0A.3
08D3:  CALL   0B9
08D4:  BSF    0A.3
....................                button_tt2 = 1; //C?p nh?t tr?ng thái c?a nút nh?n 
08D5:  MOVLW  01
08D6:  MOVWF  24
....................                output_high (DC); //B?t dèn LED 
08D7:  BSF    03.5
08D8:  BCF    08.5
08D9:  BCF    03.5
08DA:  BSF    08.5
....................                bien2 = 1; 
08DB:  MOVWF  27
....................             } 
08DC:  GOTO   0F8
....................     
....................             else if(input (button2) == 0 && button_tt2 == 1) //N?u nút nh?n du?c nh?n l?n 2 
08DD:  BSF    22.1
08DE:  MOVF   22,W
08DF:  BSF    03.5
08E0:  MOVWF  07
08E1:  BCF    03.5
08E2:  BTFSC  07.1
08E3:  GOTO   0F8
08E4:  DECFSZ 24,W
08E5:  GOTO   0F8
....................             { 
....................                while(input (button2) == 0); 
08E6:  BSF    22.1
08E7:  MOVF   22,W
08E8:  BSF    03.5
08E9:  MOVWF  07
08EA:  BCF    03.5
08EB:  BTFSS  07.1
08EC:  GOTO   0E6
....................                delay_ms (50) ; 
08ED:  MOVLW  32
08EE:  MOVWF  4A
08EF:  BCF    0A.3
08F0:  CALL   0B9
08F1:  BSF    0A.3
....................                button_tt2 = 0; //C?p nh?t tr?ng thái c?a nút nh?n 
08F2:  CLRF   24
....................                output_low (DC); //T?t dèn LED 
08F3:  BSF    03.5
08F4:  BCF    08.5
08F5:  BCF    03.5
08F6:  BCF    08.5
....................                bien2 = 0; 
08F7:  CLRF   27
....................             } 
....................     
....................             if(bien2 == 1) 
08F8:  DECFSZ 27,W
08F9:  GOTO   112
....................             { 
....................                LCD_putcmd(0x94); 
08FA:  MOVLW  94
08FB:  MOVWF  49
08FC:  BCF    0A.3
08FD:  CALL   0DE
08FE:  BSF    0A.3
....................                delay_ms (50); 
08FF:  MOVLW  32
0900:  MOVWF  4A
0901:  BCF    0A.3
0902:  CALL   0B9
0903:  BSF    0A.3
....................                Printf(LCD_putchar,"TB2:1   Humi:OFF   "); 
0904:  MOVLW  24
0905:  BSF    03.6
0906:  MOVWF  0D
0907:  MOVLW  00
0908:  MOVWF  0F
0909:  BCF    0A.3
090A:  BCF    03.6
090B:  CALL   117
090C:  BSF    0A.3
....................                output_high (DC); 
090D:  BSF    03.5
090E:  BCF    08.5
090F:  BCF    03.5
0910:  BSF    08.5
....................                }  
0911:  GOTO   12C
....................            else if(bien2 == 0){ 
0912:  MOVF   27,F
0913:  BTFSS  03.2
0914:  GOTO   12C
....................                LCD_putcmd(0x94); 
0915:  MOVLW  94
0916:  MOVWF  49
0917:  BCF    0A.3
0918:  CALL   0DE
0919:  BSF    0A.3
....................                delay_ms (50); 
091A:  MOVLW  32
091B:  MOVWF  4A
091C:  BCF    0A.3
091D:  CALL   0B9
091E:  BSF    0A.3
....................                Printf(LCD_putchar,"TB2:0   Humi:OFF   "); 
091F:  MOVLW  2E
0920:  BSF    03.6
0921:  MOVWF  0D
0922:  MOVLW  00
0923:  MOVWF  0F
0924:  BCF    0A.3
0925:  BCF    03.6
0926:  CALL   117
0927:  BSF    0A.3
....................                output_low (DC); 
0928:  BSF    03.5
0929:  BCF    08.5
092A:  BCF    03.5
092B:  BCF    08.5
....................             } 
....................                 
....................             // THIET BI 3 
....................             if(input (button3) == 0 && button_tt3 == 0) //N?u nút nh?n du?c nh?n l?n 1 
092C:  BSF    22.2
092D:  MOVF   22,W
092E:  BSF    03.5
092F:  MOVWF  07
0930:  BCF    03.5
0931:  BTFSC  07.2
0932:  GOTO   14D
0933:  MOVF   25,F
0934:  BTFSS  03.2
0935:  GOTO   14D
....................             { 
....................                while(input (button3) == 0 && button_tt3 == 0); 
0936:  BSF    22.2
0937:  MOVF   22,W
0938:  BSF    03.5
0939:  MOVWF  07
093A:  BCF    03.5
093B:  BTFSC  07.2
093C:  GOTO   140
093D:  MOVF   25,F
093E:  BTFSC  03.2
093F:  GOTO   136
....................                delay_ms (50) ; 
0940:  MOVLW  32
0941:  MOVWF  4A
0942:  BCF    0A.3
0943:  CALL   0B9
0944:  BSF    0A.3
....................                button_tt3 = 1; //C?p nh?t tr?ng thái c?a nút nh?n 
0945:  MOVLW  01
0946:  MOVWF  25
....................                output_high (LAMP); //B?t dèn LED 
0947:  BSF    03.5
0948:  BCF    08.4
0949:  BCF    03.5
094A:  BSF    08.4
....................                bien3 = 1; 
094B:  MOVWF  28
....................             } 
094C:  GOTO   168
....................     
....................             else if(input (button3) == 0 && button_tt3 == 1) //N?u nút nh?n du?c nh?n l?n 2 
094D:  BSF    22.2
094E:  MOVF   22,W
094F:  BSF    03.5
0950:  MOVWF  07
0951:  BCF    03.5
0952:  BTFSC  07.2
0953:  GOTO   168
0954:  DECFSZ 25,W
0955:  GOTO   168
....................             { 
....................                while(input (button3) == 0); 
0956:  BSF    22.2
0957:  MOVF   22,W
0958:  BSF    03.5
0959:  MOVWF  07
095A:  BCF    03.5
095B:  BTFSS  07.2
095C:  GOTO   156
....................                delay_ms (50) ; 
095D:  MOVLW  32
095E:  MOVWF  4A
095F:  BCF    0A.3
0960:  CALL   0B9
0961:  BSF    0A.3
....................                button_tt3 = 0; //C?p nh?t tr?ng thái c?a nút nh?n            
0962:  CLRF   25
....................                output_low (LAMP); //T?t dèn LED 
0963:  BSF    03.5
0964:  BCF    08.4
0965:  BCF    03.5
0966:  BCF    08.4
....................                bien3 = 0; 
0967:  CLRF   28
....................             } 
....................     
....................             if(bien3 == 1) 
0968:  DECFSZ 28,W
0969:  GOTO   182
....................             { 
....................                LCD_putcmd(0xD4); 
096A:  MOVLW  D4
096B:  MOVWF  49
096C:  BCF    0A.3
096D:  CALL   0DE
096E:  BSF    0A.3
....................                delay_ms (50) ; 
096F:  MOVLW  32
0970:  MOVWF  4A
0971:  BCF    0A.3
0972:  CALL   0B9
0973:  BSF    0A.3
....................                Printf(LCD_putchar,"TB3:1   Inte:OFF   ");  
0974:  MOVLW  38
0975:  BSF    03.6
0976:  MOVWF  0D
0977:  MOVLW  00
0978:  MOVWF  0F
0979:  BCF    0A.3
097A:  BCF    03.6
097B:  CALL   117
097C:  BSF    0A.3
....................                output_high (LAMP);     
097D:  BSF    03.5
097E:  BCF    08.4
097F:  BCF    03.5
0980:  BSF    08.4
....................                }  
0981:  GOTO   19C
....................              else if(bien3 == 0){ 
0982:  MOVF   28,F
0983:  BTFSS  03.2
0984:  GOTO   19C
....................                LCD_putcmd(0xD4); 
0985:  MOVLW  D4
0986:  MOVWF  49
0987:  BCF    0A.3
0988:  CALL   0DE
0989:  BSF    0A.3
....................                delay_ms (50) ; 
098A:  MOVLW  32
098B:  MOVWF  4A
098C:  BCF    0A.3
098D:  CALL   0B9
098E:  BSF    0A.3
....................                Printf(LCD_putchar,"TB3:0   Inte:OFF   ");  
098F:  MOVLW  42
0990:  BSF    03.6
0991:  MOVWF  0D
0992:  MOVLW  00
0993:  MOVWF  0F
0994:  BCF    0A.3
0995:  BCF    03.6
0996:  CALL   117
0997:  BSF    0A.3
....................                output_low (LAMP); //T?t dèn LED 
0998:  BSF    03.5
0999:  BCF    08.4
099A:  BCF    03.5
099B:  BCF    08.4
....................             } 
....................     
....................              
....................             break; 
099C:  GOTO   311
....................     
....................             case 1: 
....................              
....................             LCD_putcmd(0x80); 
099D:  MOVLW  80
099E:  MOVWF  49
099F:  BCF    0A.3
09A0:  CALL   0DE
09A1:  BSF    0A.3
....................             Printf(LCD_putchar,"Active Mode: Auto  "); 
09A2:  MOVLW  4C
09A3:  BSF    03.6
09A4:  MOVWF  0D
09A5:  MOVLW  00
09A6:  MOVWF  0F
09A7:  BCF    0A.3
09A8:  BCF    03.6
09A9:  CALL   117
09AA:  BSF    0A.3
....................              
....................              
....................             Doc_ADC(); 
09AB:  BCF    0A.3
09AC:  GOTO   2C9
09AD:  BSF    0A.3
....................             // cam bien nhiet do 
....................             if(Temp >= 40) 
09AE:  CLRF   3E
09AF:  CLRF   3D
09B0:  MOVLW  20
09B1:  MOVWF  3C
09B2:  MOVLW  84
09B3:  MOVWF  3B
09B4:  MOVF   3A,W
09B5:  MOVWF  42
09B6:  MOVF   39,W
09B7:  MOVWF  41
09B8:  MOVF   38,W
09B9:  MOVWF  40
09BA:  MOVF   37,W
09BB:  MOVWF  3F
09BC:  BCF    0A.3
09BD:  CALL   4D8
09BE:  BSF    0A.3
09BF:  BTFSC  03.0
09C0:  GOTO   1C3
09C1:  BTFSS  03.2
09C2:  GOTO   1FB
....................             { 
....................                LCD_putcmd(0xC0); 
09C3:  MOVLW  C0
09C4:  MOVWF  49
09C5:  BCF    0A.3
09C6:  CALL   0DE
09C7:  BSF    0A.3
....................                delay_ms (50) ; 
09C8:  MOVLW  32
09C9:  MOVWF  4A
09CA:  BCF    0A.3
09CB:  CALL   0B9
09CC:  BSF    0A.3
....................                printf(LCD_putchar,"TB1:1   Temp:%3.1f", Temp); 
09CD:  MOVLW  56
09CE:  BSF    03.6
09CF:  MOVWF  0D
09D0:  MOVLW  00
09D1:  MOVWF  0F
09D2:  BCF    03.0
09D3:  MOVLW  0D
09D4:  BCF    03.6
09D5:  MOVWF  3B
09D6:  BCF    0A.3
09D7:  CALL   517
09D8:  BSF    0A.3
09D9:  MOVLW  02
09DA:  MOVWF  04
09DB:  MOVF   3A,W
09DC:  MOVWF  3E
09DD:  MOVF   39,W
09DE:  MOVWF  3D
09DF:  MOVF   38,W
09E0:  MOVWF  3C
09E1:  MOVF   37,W
09E2:  MOVWF  3B
09E3:  MOVLW  01
09E4:  MOVWF  3F
09E5:  BCF    0A.3
09E6:  CALL   5BD
09E7:  BSF    0A.3
....................                LCD_PutChar(223); 
09E8:  MOVLW  DF
09E9:  MOVWF  48
09EA:  BCF    0A.3
09EB:  CALL   10B
09EC:  BSF    0A.3
....................                LCD_PutChar("C "); 
09ED:  MOVLW  60
09EE:  BSF    03.6
09EF:  MOVWF  0D
09F0:  MOVLW  00
09F1:  MOVWF  0F
09F2:  BCF    0A.3
09F3:  BCF    03.6
09F4:  CALL   117
09F5:  BSF    0A.3
....................                output_high(MB); 
09F6:  BSF    03.5
09F7:  BCF    08.6
09F8:  BCF    03.5
09F9:  BSF    08.6
....................             } 
09FA:  GOTO   22D
....................     
....................             else 
....................             { 
....................              LCD_putcmd(0xC0); 
09FB:  MOVLW  C0
09FC:  MOVWF  49
09FD:  BCF    0A.3
09FE:  CALL   0DE
09FF:  BSF    0A.3
....................              printf(LCD_putchar,"TB1:0   Temp:%3.1f", Temp); 
0A00:  MOVLW  62
0A01:  BSF    03.6
0A02:  MOVWF  0D
0A03:  MOVLW  00
0A04:  MOVWF  0F
0A05:  BCF    03.0
0A06:  MOVLW  0D
0A07:  BCF    03.6
0A08:  MOVWF  3B
0A09:  BCF    0A.3
0A0A:  CALL   517
0A0B:  BSF    0A.3
0A0C:  MOVLW  02
0A0D:  MOVWF  04
0A0E:  MOVF   3A,W
0A0F:  MOVWF  3E
0A10:  MOVF   39,W
0A11:  MOVWF  3D
0A12:  MOVF   38,W
0A13:  MOVWF  3C
0A14:  MOVF   37,W
0A15:  MOVWF  3B
0A16:  MOVLW  01
0A17:  MOVWF  3F
0A18:  BCF    0A.3
0A19:  CALL   5BD
0A1A:  BSF    0A.3
....................              LCD_PutChar(223); 
0A1B:  MOVLW  DF
0A1C:  MOVWF  48
0A1D:  BCF    0A.3
0A1E:  CALL   10B
0A1F:  BSF    0A.3
....................              LCD_PutChar("C "); 
0A20:  MOVLW  6C
0A21:  BSF    03.6
0A22:  MOVWF  0D
0A23:  MOVLW  00
0A24:  MOVWF  0F
0A25:  BCF    0A.3
0A26:  BCF    03.6
0A27:  CALL   117
0A28:  BSF    0A.3
....................              output_low(MB); 
0A29:  BSF    03.5
0A2A:  BCF    08.6
0A2B:  BCF    03.5
0A2C:  BCF    08.6
....................             } 
....................             //cam bien do am dat 
....................             if(humidity >= 50) 
0A2D:  CLRF   3E
0A2E:  CLRF   3D
0A2F:  MOVLW  48
0A30:  MOVWF  3C
0A31:  MOVLW  84
0A32:  MOVWF  3B
0A33:  MOVF   32,W
0A34:  MOVWF  42
0A35:  MOVF   31,W
0A36:  MOVWF  41
0A37:  MOVF   30,W
0A38:  MOVWF  40
0A39:  MOVF   2F,W
0A3A:  MOVWF  3F
0A3B:  BCF    0A.3
0A3C:  CALL   4D8
0A3D:  BSF    0A.3
0A3E:  BTFSC  03.0
0A3F:  GOTO   242
0A40:  BTFSS  03.2
0A41:  GOTO   276
....................             { 
....................              LCD_putcmd(0x94); 
0A42:  MOVLW  94
0A43:  MOVWF  49
0A44:  BCF    0A.3
0A45:  CALL   0DE
0A46:  BSF    0A.3
....................              delay_ms (50) ; 
0A47:  MOVLW  32
0A48:  MOVWF  4A
0A49:  BCF    0A.3
0A4A:  CALL   0B9
0A4B:  BSF    0A.3
....................              Printf(LCD_putchar,"TB2:1   Humi:%3.1f%% ", humidity);  
0A4C:  MOVLW  6E
0A4D:  BSF    03.6
0A4E:  MOVWF  0D
0A4F:  MOVLW  00
0A50:  MOVWF  0F
0A51:  BCF    03.0
0A52:  MOVLW  0D
0A53:  BCF    03.6
0A54:  MOVWF  3B
0A55:  BCF    0A.3
0A56:  CALL   517
0A57:  BSF    0A.3
0A58:  MOVLW  02
0A59:  MOVWF  04
0A5A:  MOVF   32,W
0A5B:  MOVWF  3E
0A5C:  MOVF   31,W
0A5D:  MOVWF  3D
0A5E:  MOVF   30,W
0A5F:  MOVWF  3C
0A60:  MOVF   2F,W
0A61:  MOVWF  3B
0A62:  MOVLW  01
0A63:  MOVWF  3F
0A64:  BCF    0A.3
0A65:  CALL   5BD
0A66:  BSF    0A.3
0A67:  MOVLW  25
0A68:  MOVWF  48
0A69:  BCF    0A.3
0A6A:  CALL   10B
0A6B:  BSF    0A.3
0A6C:  MOVLW  20
0A6D:  MOVWF  48
0A6E:  BCF    0A.3
0A6F:  CALL   10B
0A70:  BSF    0A.3
....................              output_high (DC) ; 
0A71:  BSF    03.5
0A72:  BCF    08.5
0A73:  BCF    03.5
0A74:  BSF    08.5
....................             } 
0A75:  GOTO   2A9
....................             else  
....................             { 
....................              LCD_putcmd(0x94); 
0A76:  MOVLW  94
0A77:  MOVWF  49
0A78:  BCF    0A.3
0A79:  CALL   0DE
0A7A:  BSF    0A.3
....................              delay_ms (50) ; 
0A7B:  MOVLW  32
0A7C:  MOVWF  4A
0A7D:  BCF    0A.3
0A7E:  CALL   0B9
0A7F:  BSF    0A.3
....................              Printf(LCD_putchar,"TB2:0   Humi:%3.1f%% ", humidity);  
0A80:  MOVLW  79
0A81:  BSF    03.6
0A82:  MOVWF  0D
0A83:  MOVLW  00
0A84:  MOVWF  0F
0A85:  BCF    03.0
0A86:  MOVLW  0D
0A87:  BCF    03.6
0A88:  MOVWF  3B
0A89:  BCF    0A.3
0A8A:  CALL   517
0A8B:  BSF    0A.3
0A8C:  MOVLW  02
0A8D:  MOVWF  04
0A8E:  MOVF   32,W
0A8F:  MOVWF  3E
0A90:  MOVF   31,W
0A91:  MOVWF  3D
0A92:  MOVF   30,W
0A93:  MOVWF  3C
0A94:  MOVF   2F,W
0A95:  MOVWF  3B
0A96:  MOVLW  01
0A97:  MOVWF  3F
0A98:  BCF    0A.3
0A99:  CALL   5BD
0A9A:  BSF    0A.3
0A9B:  MOVLW  25
0A9C:  MOVWF  48
0A9D:  BCF    0A.3
0A9E:  CALL   10B
0A9F:  BSF    0A.3
0AA0:  MOVLW  20
0AA1:  MOVWF  48
0AA2:  BCF    0A.3
0AA3:  CALL   10B
0AA4:  BSF    0A.3
....................              output_low (DC) ; 
0AA5:  BSF    03.5
0AA6:  BCF    08.5
0AA7:  BCF    03.5
0AA8:  BCF    08.5
....................             } 
....................            
....................           // cam bien ánh sang 
....................            
....................             if(Inte >= 600) 
0AA9:  CLRF   3E
0AAA:  CLRF   3D
0AAB:  MOVLW  16
0AAC:  MOVWF  3C
0AAD:  MOVLW  88
0AAE:  MOVWF  3B
0AAF:  MOVF   36,W
0AB0:  MOVWF  42
0AB1:  MOVF   35,W
0AB2:  MOVWF  41
0AB3:  MOVF   34,W
0AB4:  MOVWF  40
0AB5:  MOVF   33,W
0AB6:  MOVWF  3F
0AB7:  BCF    0A.3
0AB8:  CALL   4D8
0AB9:  BSF    0A.3
0ABA:  BTFSC  03.0
0ABB:  GOTO   2BE
0ABC:  BTFSS  03.2
0ABD:  GOTO   2E8
....................             {   
....................              LCD_putcmd(0xD4); 
0ABE:  MOVLW  D4
0ABF:  MOVWF  49
0AC0:  BCF    0A.3
0AC1:  CALL   0DE
0AC2:  BSF    0A.3
....................              delay_ms (50) ; 
0AC3:  MOVLW  32
0AC4:  MOVWF  4A
0AC5:  BCF    0A.3
0AC6:  CALL   0B9
0AC7:  BSF    0A.3
....................              Printf(LCD_putchar,"TB3:1   Inte:%4.1f",Inte);     
0AC8:  MOVLW  84
0AC9:  BSF    03.6
0ACA:  MOVWF  0D
0ACB:  MOVLW  00
0ACC:  MOVWF  0F
0ACD:  BCF    03.0
0ACE:  MOVLW  0D
0ACF:  BCF    03.6
0AD0:  MOVWF  3B
0AD1:  BCF    0A.3
0AD2:  CALL   517
0AD3:  BSF    0A.3
0AD4:  MOVLW  03
0AD5:  MOVWF  04
0AD6:  MOVF   36,W
0AD7:  MOVWF  3E
0AD8:  MOVF   35,W
0AD9:  MOVWF  3D
0ADA:  MOVF   34,W
0ADB:  MOVWF  3C
0ADC:  MOVF   33,W
0ADD:  MOVWF  3B
0ADE:  MOVLW  01
0ADF:  MOVWF  3F
0AE0:  BCF    0A.3
0AE1:  CALL   5BD
0AE2:  BSF    0A.3
....................              output_high (LAMP) ; 
0AE3:  BSF    03.5
0AE4:  BCF    08.4
0AE5:  BCF    03.5
0AE6:  BSF    08.4
....................             }  
0AE7:  GOTO   311
....................             else 
....................             { 
....................              LCD_putcmd(0xD4); 
0AE8:  MOVLW  D4
0AE9:  MOVWF  49
0AEA:  BCF    0A.3
0AEB:  CALL   0DE
0AEC:  BSF    0A.3
....................              delay_ms (50) ; 
0AED:  MOVLW  32
0AEE:  MOVWF  4A
0AEF:  BCF    0A.3
0AF0:  CALL   0B9
0AF1:  BSF    0A.3
....................              Printf(LCD_putchar,"TB3:0   Inte:%4.1f",Inte);    
0AF2:  MOVLW  8E
0AF3:  BSF    03.6
0AF4:  MOVWF  0D
0AF5:  MOVLW  00
0AF6:  MOVWF  0F
0AF7:  BCF    03.0
0AF8:  MOVLW  0D
0AF9:  BCF    03.6
0AFA:  MOVWF  3B
0AFB:  BCF    0A.3
0AFC:  CALL   517
0AFD:  BSF    0A.3
0AFE:  MOVLW  03
0AFF:  MOVWF  04
0B00:  MOVF   36,W
0B01:  MOVWF  3E
0B02:  MOVF   35,W
0B03:  MOVWF  3D
0B04:  MOVF   34,W
0B05:  MOVWF  3C
0B06:  MOVF   33,W
0B07:  MOVWF  3B
0B08:  MOVLW  01
0B09:  MOVWF  3F
0B0A:  BCF    0A.3
0B0B:  CALL   5BD
0B0C:  BSF    0A.3
....................              output_low(LAMP) ; 
0B0D:  BSF    03.5
0B0E:  BCF    08.4
0B0F:  BCF    03.5
0B10:  BCF    08.4
....................             }   
....................               
....................             break; 
....................       } 
0B11:  GOTO   02F
....................    } 
....................   } 
....................   
0B12:  SLEEP

Configuration Fuses:
   Word  1: 3F3A   HS NOWDT NOPUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
